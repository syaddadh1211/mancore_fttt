#% text_encoding = iso8859_1
_package sw
$

remex(:pni_trace_result_lister)
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
def_slotted_exemplar(:pni_trace_result_lister,
{
	{ :owner         , _unset },
	{ :menu_items    , _unset },
	{ :properties    , _unset },    #   (not currently used)
	{ :result_trees  , _unset },
	{ :sub_menus     , _unset },
	{ :changed_trees , _unset }
},
{:model})
$

# Changes for pni_trace_app_plugin - Expose actions to run the
# trace, display the trace results and get the trace results
# trees independently of each other
# Changes for pni_trace_result_lister - Allow trace plugin
# access to the result_trees, decouple the result tree
# generation from the result tree display
_pragma(classify_level=restricted,topic=pni_tracing_plugin)
pni_trace_result_lister.define_slot_access( :result_trees, :readable, :public )
$

_pragma(classify_level=restricted)
pni_trace_result_lister.define_shared_constant(:html_help_file_name, "Default.htm", :public)
$
_pragma(classify_level=restricted,topic=pni_tracing_plugin)
## Currently take us to the top of the trace help as there's no
## direct help id for the results tab:
pni_trace_result_lister.define_shared_variable(:help_id, 212070, :public)
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
pni_trace_result_lister.define_shared_variable(:current_nf_manager, _unset, :public)
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
pni_trace_result_lister.define_shared_variable(:start_nodes, _unset, :public)
$

_pragma(classify_level=restricted)
	##
	##  Table of rules with the available reports for each
	##  combination of trace medium and trace cost type.
	##
pni_trace_result_lister.define_shared_constant( :report_rules, dual_key_a_table.new(), _false )
$
_block
	_local l_rules << pni_trace_result_lister.report_rules
	#   Note:   Index 1 is the medium. Index 2 is the cost type.

	l_rules[ :independent, :signal_loss ] << { :results_tree_report         , :schematics ,
						   :rf_path_loss_detailed_report, :rf_path_loss_summary_report }

	l_rules[ :rf         , :signal_loss ] << { :results_tree_report         , :rf_path_loss_detailed_report,
						   :rf_path_loss_summary_report , :schematics }

	l_rules[ :rf         , :none        ] << { :results_tree_report         , :rf_path_loss_detailed_report,
						   :rf_path_loss_summary_report , :schematics }

	l_rules[ :optical    , :signal_loss ] << { :results_tree_report         , :path_loss_detailed_report,
						   :path_loss_summary_report    , :schematics }
_endblock
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.new( owner )
	## 
	##  Instantiate.
	##
	>> _clone.init( owner )
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.init( owner )
	## 
	##  Initialise.
	##

	.owner << owner
	#
	#   FUTURE: While .properties is not currently used, there is a
	#           use for it, which is to hold a copy of
	#           .owner.trace_level,
	#           .owner.trace_media, etc, to avoid the
	#           problem that the user can change them after doing a
	#           trace, such that their values, as picked up
	#           dynamically in various methods in this file, may not
	#           be as expected.
	#
	.properties   << property_list.new()
	.menu_items   << property_list.new()
	.result_trees << property_list.new()
	.sub_menus    << property_list.new()
	_return _super.init()
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.realised?
	##
	##  Returns TRUE if there has been at least one call to activate
	##  the lister.
	##
	_return _not .menu_items.empty?
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.activate_in( a_frame )
	##
	##  Realises the result lister in the specified frame.
	##

	main_rc << rowcol.new( a_frame, 4, 1, :pixel,
			       :outer_spacing, 3,
			       :row_spacing, 3,
			       :default_row_alignment, :fill,
			       :default_col_alignment, :fill,
			       :row_resize_values, {0,0,0,100} )
	
	rc_1 << rowcol.new( main_rc, 1, 2, :pixel,
			    :row, 1, :col, 1,
			    :col_resize_values, {0,100} )

	tb << toolbar.new( rc_1, _false )
	tb.row << 1
	tb.col << 1
	tb.col_spacing << 0
	tb.outer_spacing << 2
	tb.border? << _true
	tb.row_alignment << :fill
	tb.default_row_alignment << :centre
	tb.tight_fit_x? << _true
	
	ri << smallworld_product.get_raster_image( :goto_object     , :ui_resources )
	gr << smallworld_product.get_raster_image( :goto_object_grey, :ui_resources )
	.menu_items[:goto] << image_button_item.new( tb,
						     ri,
						     _self, :goto_selection|()| ,
						     :identifier, :goto,
						     :balloon_help_text, _self.message(:results_goto_selection),
						     :insensitive_image, gr )
	.menu_items[:goto].set_property( :has_border?, _false )
	
	ri << smallworld_product.get_raster_image( :select_geometry     , :ui_resources )
	gr << smallworld_product.get_raster_image( :select_geometry_grey, :ui_resources )
	.menu_items[:sel_in_map] << image_button_item.new( tb,
							   ri,
							   _self, :select_in_map|()| ,
							   :identifier, :select_in_map,
							   :balloon_help_text, _self.message(:results_select_in_map),
							   :insensitive_image, gr )
	.menu_items[:sel_in_map].set_property( :has_border?, _false )
	
	ri << smallworld_product.get_raster_image( :highlight      , :ui_resources )
	gr << smallworld_product.get_raster_image( :highlight_grey , :ui_resources )
	.menu_items[:highlight] << image_button_item.new( tb,
							  ri,
							  _self, :highlight_selection|()|,
							  :identifier, :highlight,
							  :balloon_help_text, _self.message(:highlight_selection),
							  :insensitive_image, gr )
	.menu_items[:highlight].set_property( :has_border?, _false )

	ri << smallworld_product.get_raster_image( :clear      , :ui_resources )
	gr << smallworld_product.get_raster_image( :clear_grey , :ui_resources )
	.menu_items[:clear] << image_button_item.new( tb,
						      ri,
						      _self, :clear_results|()|,
						      :identifier, :clear,
						      :balloon_help_text, _self.message(:results_clear),
						      :insensitive_image, gr )
	.menu_items[:clear].set_property( :has_border?, _false )

	ri << smallworld_product.get_raster_image( :list     , :ui_resources )
	gr << smallworld_product.get_raster_image( :list_grey, :ui_resources )
	.menu_items[:explorer] << image_button_item.new( tb,
							 ri,
							 _self, :send_to_explorer|()| ,
							 :identifier, :send_to_explorer_button,
							 :balloon_help_text, _self.message(:results_browse),
							 :insensitive_image, gr )
	.menu_items[:explorer].set_property( :has_border?, _false )

	ri << smallworld_product.get_raster_image( :update_fibre_priority     , :mit_tracing_plugin )
	gr << smallworld_product.get_raster_image( :update_fibre_priority_grey, :mit_tracing_plugin )
	.menu_items[:update_fibre_priority] << image_button_item.new( tb,
								      ri,
								      _self, :update_fibre_priority|()| ,
								      :identifier, :update_fibre_priority_button,
								      :balloon_help_text, _self.message(:update_fibre_priority),
								      :insensitive_image, gr )
	.menu_items[:update_fibre_priority].set_property( :has_border?, _false )

	ri << smallworld_product.get_raster_image( :send_to_diversity_checker     , :diversity_gui_plugin )
	gr << smallworld_product.get_raster_image( :send_to_diversity_checker_grey, :diversity_gui_plugin )
	.menu_items[:send_to_diversity] << image_button_item.new( tb,
								  ri,
								  _self, :send_to_diversity_checker|()| ,
								  :identifier, :send_to_diversity,
								  :enabled?, _false,
								  :balloon_help_text, _self.message(:send_to_diversity),
								  :insensitive_image, gr )
	.menu_items[:send_to_diversity].set_property( :has_border?, _false )

	
	ri << smallworld_product.get_raster_image( :help, :ui_resources )
	.menu_items[:help_button] << image_button_item.new( rc_1,
							    ri,
							    _self, :|help()|,
							    :col_alignment , :right,
							    :balloon_help_text, _self.message(:help),
							    :row, 1, :col, 2,
							    :identifier, :help )

	
	rc_2 << rowcol.new( main_rc, 1, _unset, :pixel,
			    :row, 2, :col, 1,
			    :col_alignment, :left,
			    :default_row_alignment, :centre )
	
	items << { {:overview, _self.message( :overview )},
		   {:detail, _self.message( :detail )} }
	
	.menu_items[:display_level] << radio_group_item.new( rc_2, _self.message( :display ),
							     :items, items,
							     :model, _self,
							     :change_selector, :|display_level<<|,
							     :groupbox?, _true,
							     :value, :detail,
							     :identifier, :display )	

	generate_rc << rowcol.new( rc_2, 1, _unset, :pixel,
				   :left_spacing, 24,
				   :col_spacing, 4,
				   :col_alignment, :left,
				   :default_row_alignment, :centre )
	
	label_item.new( generate_rc, _self.message( :generate ),
			:model, _self,
			:identifier, :generate_label )

	items << { {:results_tree_report, _self.message( :results_tree_report)},
		   {:path_loss_detailed_report, _self.message( :path_loss_detailed_report )},
		   {:path_loss_summary_report, _self.message( :path_loss_summary_report )},
		   {:rf_path_loss_detailed_report, _self.message( :rf_path_loss_detailed_report )},
		   {:rf_path_loss_summary_report, _self.message( :rf_path_loss_summary_report )},
		   {:schematics, _self.message( :schematics )},
		   {:rw_trace_diagram, "Export Trace"} # TODO _self.message( :rw_trace_diagram )
		   }
	
	.menu_items[:generate] << text_choice_item.new( generate_rc, "",
							:items, items,
							:model, _self,
							:min_width, 150,
							:identifier, :generate )

	ri << smallworld_product.get_raster_image( :run, :ui_resources )
	.menu_items[:go] << image_button_item.new_safe( generate_rc ,
							ri,
							_self, :go|()|,
							:identifier, :run_trace)

	
	.menu_items[:label] << label_item.new( main_rc , "",
					       :model, _self,
					       :col_alignment, :left,
					       :row, 3, :col, 1,
					       :identifier, :_pni_trace_result_lister_activate_in_13_label )

        # create the result tree
        .menu_items[:results_list] << tlc <<
                tree_list_view_component.new( :tlc , _unset )
	
        # configure component
	tlc.nrows << 12
	
        tlc.list_highlight_type   << :text_bar
        tlc.highlight_colour      << colour.called(:blue)
        tlc.text_highlight_colour << colour.called(:white)
	
        tlc.popup_handler << _self.popup_handler(:results)
        tlc.mode << tlc.popup_handler.mode << :many
        tlc.horizontal_scrollbars? << _true

	tlc.add_dependent( _self )
        tlc.popup_handler.add_dependent( _self )
	
	rc_4 << rowcol.new( main_rc, 1, _unset, :pixel,
			    :row, 4, :col, 1,
			    :default_row_alignment, :fill,
			    :default_col_alignment, :fill )
        tlc.build_in_framework( rc_4 )

	_self.manage_actions( :popup_init )
	
        _return main_rc
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.popup_handler( type )
	##
	##  Creates a new popup_handler for given TYPE (usually
	##  :results). Uses the entries defined in mapping constant
	##  _self.menu_buttons under the key TYPE, which is passed as an
	##  argument.
	##
	ph          << popup_handler.new( _unset, _unset )
	popup_order << rope.new_with( :default, :separator )
	mbs         << _self.menu_buttons[ type ]   #   type is normally :results
        _for msg_name, meth_and_args _over mbs.fast_keys_and_elements()
        _loop
		ph.popup_definition.register_button_event( msg_name, _self.message( msg_name ) )
		popup_order.add_last( msg_name )
        _endloop
        ph.popup_order << popup_order
        _return ph
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.generate_trace_results_tree( trace_level, current_nf_manager, start_nodes )
	##
	##  Create 2 trees:
	##
	##      1.  raw trace results tree needed by
	##          update_fiber_priorities_of_results()
	##
	##      2.  first displayable results tree corresponding to the
	##          specified trace level
	##
	##  Called solely by pni_trace_dialog.do_follow().
	##
	##  NOTE:   When we are called, activate_in() has not
	##          necessarily happened yet, so we cannot acces
	##          .menu_items[:display_level] etc herein.
	##
	.result_trees.empty()   #   clear all previous results
	_self.current_nf_manager << current_nf_manager
	_self.start_nodes        << start_nodes
	display_level            << :detail     #   using this as the default
	#
	#   NOTE:   Could have used :overview above but :detail (as the
	#           name suggests) gives more detail and is therefore
	#           more useful as the default setting.
	#
	#   1.  Generate raw tree data. This is needed at least by
	#       update_fiber_priorities_of_results(). It may in future
	#       be needed for other purposes too. So we always generate
	#       it, even though fiber priority updates only make sense
	#       from Signal trace raw results.
	#
	#       Note:   The display_level is specified as :detail in the
	#               call below, but I do not think that matters.
	#
	result_tree << _self.int!generate_results_tree( trace_level, display_level, current_nf_manager, start_nodes )
	.result_trees[ :raw ] << result_tree
	#
	#   2.  Generate displayable results tree for specified trace
	#       level:
	#
	.result_trees[ display_level ] << result_tree
	#
	#   At this point we will always have a :raw key in
	#   .result_trees, and we will also have key :overview or key
	#   :detail depending on display_level.
	#
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_private _method pni_trace_result_lister.generate_display_trace_results_tree(
			trace_level, display_level, current_nf_manager, start_nodes)
    ##
	##  Create a displayable result tree to be used for the tree
	##  window.
	##
	##  Called solely on self, from generate_trace_results_tree()
	##  and other methods on same class.
    ##
	new_tree << _self.int!generate_results_tree( trace_level, display_level, current_nf_manager, start_nodes )
	.result_trees[ display_level ] << new_tree

	_return new_tree
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_private _method pni_trace_result_lister.int!generate_results_tree( trace_level, display_level, current_nf_manager, start_nodes )
	##
	##  Work-horse code shared by generate_trace_results_tree() and
	##  generate_display_trace_results_tree().
	##
	results                      << current_nf_manager.results
	replace_method               << _self.nf_link_node_replacing_methods[ display_level ]
	collapse_neighboring_equals? << ( display_level _isnt :raw )    #   collapse equal neighbours in tree except for :raw
	descr_method                 << _self.display_string_method_for_trace[ display_level ]
        # build the tree on top result_tree
	master_result_tree           << _self.make_master_root_tree_for_current_trace( trace_level )
	_if results.empty? _orif start_nodes.empty?
        _then
                _return master_result_tree
        _endif
	current_engine    << current_nf_manager.engine
        start_node_number << 0
	trace_dialog <<  .owner
        _for start_node _over start_nodes.fast_elements()
        _loop
		start_node_number +<< 1
		_if start_node_number = 1
                _then
			trace_dir_str   <<  _if trace_dialog.trace_direction _isnt :both_ways
					    _then
						    str << trace_dialog.current_direction_description
						    str << trace_dialog.message( :direction_is, _unset, str )
						    >> str
					    _else
						    >> ""
					    _endif
			trace_media_str <<  _if trace_dialog.trace_medium _isnt :independent
					    _then
						    str << trace_dialog.current_medium_description
						    str << trace_dialog.message( :media_is, _unset, str )
						    >> str
					    _else
						    >> ""
					    _endif
			trace_stop_str  <<  _if trace_dialog.trace_cost_type _isnt :none
					    _then
						    str << trace_dialog.trace_cost_value
						    str << trace_dialog.message( :stopped_at, _unset, str )
						    >> str
					    _else
						    >> ""
					    _endif
			str << _self.message( trace_level )
			master_result_tree.display_string <<
			    write_string( _self.message( :results_tree_lev_tra_caps, _unset, str ),
					  trace_dir_str, trace_media_str, trace_stop_str )
                _endif
		trace_result_tree                            << master_result_tree.new()
		trace_result_tree.display_string             << _self.message( :start_node_number, _unset, start_node_number )
		trace_results_first_node_tree                << trace_result_tree.new()
		trace_results_first_node_tree.node           << start_node
                trace_results_first_node_tree.display_string << start_node.trace_description
                trace_result_tree.add_child( trace_results_first_node_tree )
		engine  << current_nf_manager.trace_engine_for_node( start_node ).default( current_engine )
		_if trace_dialog.trace_cost_type _isnt :none _andif
		    trace_dialog.trace_cost_value.mit_responds_to?( :unit )
                _then
                        engine.make_link_tree( trace_results_first_node_tree,
					       replace_method,
					       descr_method,
					       collapse_neighboring_equals?,
					       trace_dialog.trace_cost_value.unit )
                _else
                        engine.make_link_tree( trace_results_first_node_tree,
					       replace_method,
					       descr_method,
					       collapse_neighboring_equals? )
                _endif
                master_result_tree.add_child( trace_result_tree )
        _endloop
	#
	#   Added the following three lines to add an End Of Trace
	#   message, so users know where the trace ended. This is
	#   especially helpful in LARGE traces:
	#
        trace_results_first_node_tree << trace_result_tree.new()
	trace_results_first_node_tree.display_string << _self.message( :eot ).write_string
        master_result_tree.add_child( trace_results_first_node_tree )
	#
	#   Generate and return new tree:
	#
	#       FUTURE: If we were to make the tree more vertical by
	#               postprocessing it, that could be done here.
	#               Alternatively, mit_trace_engine.make_link_tree()
	#               could be radically revised to achieve this,
	#               which might be a better way to do it.
	#
	_return master_result_tree
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.create_gui_tree(trace_tree, _optional parent)
	##
	##  This is a simple property tree which will be displayed in a
	##  simple tree list view component.
	##
	#   We now use a tree descriptor to find the tree relevant data:
	td << mit_manager.get_tree_descriptor( _unset, _self.context)
        _return td.set_tree(trace_tree, property_tree.new(), td)
_endmethod
$

# config 

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
pni_trace_result_lister.define_shared_constant( :nf_link_node_replacing_methods,
						property_list.new_with( :overview, :get_top_level_device|()|,
									:detail  , _unset,
									:raw     , _unset ),
						_false )
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
pni_trace_result_lister.define_shared_constant( :display_string_method_for_trace,
						property_list.new_with( :overview, :trace_description,
									:detail  , :trace_description,
									:raw     , :write_string ),
						_false )
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.make_master_root_tree_for_current_trace( trace_level )
	##
	##  ???
	##
	master_root_tree << mit_diagonal_trace_result_tree.new()
	str << _self.message( trace_level )
	master_root_tree.display_string << _self.message( :results_tree_none, _unset, str )
        _return master_root_tree
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.results_list
	##
	##  Wrapper to access result tree component.
	##
        _return .menu_items[:results_list]
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
	##
	##  Defines a context for configuration like tree descriptors
	##
pni_trace_result_lister.define_shared_constant( :context, :mit_trace, :public )
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
	##
	##  Maps some action names to methods that carry them out.
	##
	##  Referenced in popup_handler() and note_change().
	##
pni_trace_result_lister.define_shared_constant( :menu_buttons,
	property_list.new_with(
		:results,
		property_list.new_with(
			:highlight_selection    , :highlight_selection|()|          ,
			:highlight              , :highlight|()|                    ,
			:results_goto_selection , :goto_selection|()|               ,
			:results_select_in_map  , :select_in_map|()|                ,
			:results_goto_all       , :goto|()|                         ,
			:set_as_start_node      , :set_selection_as_start_node|()|  ,
			:set_as_stop_node       , :set_selection_as_stop_node|()|   ,
			:update_fibre_priority  , :update_fibre_priority|()|        ,
			:send_to_diversity      , :send_to_diversity_checker|()|    ) ),
		:public )
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.goto()
	##
	##  Goes to results in map.
	##
	.owner.plugin.goto_results()
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.highlight()
	##
	##  Highlights results in map.
	##
	.owner.plugin.highlight_results()
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.clear_results()
	##
	##  Clears results.
	##
	
	_if _self.results_list _isnt _unset
	_then 
		_self.results_list.set_tree( _unset )
	_endif
	.result_trees.empty()
	.owner.clear_trace()
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.send_to_explorer()
	##
	##  Sends results to explorer.
	##
	.owner.plugin.send_to_explorer()
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.display_level << display_level
	##
	##  Called by the display level control when its setting is
	##  changed by the user.
	##
	##  Expects DISPLAY_LEVEL as :overview or :detail.
	##
	##  NOTE:   To programmatically set the display level, call
	##          set_display_level() instead. Do NOT call here.
	##
	_self.update_label()
	tree << .result_trees[ display_level ]
	_if tree.default ( { } ).size = 0
	_then
		tree << _self.generate_display_trace_results_tree(
				.owner.trace_level, display_level,
				_self.current_nf_manager, _self.start_nodes )
	_endif
	_if tree _isnt _unset
	_then 
		_self.results_list.set_expanded_tree( _self.create_gui_tree( tree ) )
	_else
		#   Not sure if we can end up here, but just in case...
		_self.results_list.set_tree( _unset )
	_endif
	_self.manage_actions()  #   enable/disable actions on dialog
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.set_display_level( display_level )
	## 
	##  Call this to set the display level. It carries out
	##  appropriate actions, and also sets the display level
	##  control.
	##
	.menu_items[:display_level].value << display_level
	_self.display_level << display_level
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.display_level
	##
	##  Display level, :overview or :detail, which determines how
	##  much detail is shown in the results tree.
	##
	_return .menu_items[:display_level].value
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.go()
	## 
	a_type << .menu_items[ :generate ].value
	action << _self.report_type_action[ a_type ]
	_self.perform( action , a_type )
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
pni_trace_result_lister.define_shared_constant(:report_type_action,
					       property_list.new_with(
						       :results_tree_report,:generate_a_text_report|()|,
						       :path_loss_detailed_report,:generate_a_text_report|()|,
						       :path_loss_summary_report,:generate_a_text_report|()|,
						       :rf_path_loss_detailed_report,:generate_a_text_report|()|,
						       :rf_path_loss_summary_report,:generate_a_text_report|()|,
						       :schematics,:start_schematics|()|,
							   :rw_trace_diagram, :start_rw_trace_diagram|()|
							     ),
					       :private 
			)
$
	
_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.start_schematics()
	## 

	.owner.plugin.create_schematic() 
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.start_rw_trace_diagram()
        start_node_number << 0

		_for start_node _over _self.start_nodes.fast_elements()
        _loop
			engine  << _self.current_nf_manager
			start_node_number +<< 1
			_if start_node_number = 1
            _then
				write("Node " + start_node_number.write_string)
				write("Start Node - " + start_node.id.write_string)
				print( start_node )
				write(newline_char)
				#_self.rw_process_nodes(engine.trace_engine_for_node( start_node ).all_nodes())
				_self.rw_build_network_trace_path(start_node, engine.trace_engine_for_node( start_node ).all_nodes())				
			_else
				write("Node " + start_node_number.write_string)			
				write("Start Node - " + start_node.id.write_string)
				print( start_node )
				write(newline_char)
				#_self.rw_process_nodes(engine.trace_engine_for_node( start_node ).all_nodes())
				_self.rw_build_network_trace_path(start_node, engine.trace_engine_for_node( start_node ).all_nodes())	
			_endif
		_endloop	
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing)
_method pni_trace_result_lister.generate_a_text_report( report_type )
	##
	##  Generates a trace report as text which it displays in a text window (from which it can
	##  be selected and saved to either the clipboard or to a file).
	##
	trace_level << .owner.trace_level
	mgr         << .owner.managers[ trace_level ]
	#
	#   Form descriptor to index into .sub_menus to find the report window (if cached):
	#
	key         << report_type + :! + trace_level
	#
	#   Prepare the proper window for the reports:
	#
	rv_defs     << _self.report_viewer_definitions[ key ]
	rpt_win     << .sub_menus[ key ]
	generate?   << report_type = :results_tree_report _orif rv_defs _is _unset
	_if rpt_win _is _unset
        _then
		_if generate?
                _then
			rpt_win << report_previewer.new( 100, 30 ).activate()
                _else
			rpt_win << rv_defs.new().activate()
                _endif
		rpt_win.title     << _self.message( report_type )
		.sub_menus[ key ] << rpt_win    #   cache the report window as a sub_menu
        _else
		rpt_win.clear()
        _endif
	#
	#   Generate the report:
	#
	_if generate?
        _then
		_self.generate_results_tree_report( rpt_win )
        _else
		rpt_win.populate_data_from_trace( mgr, _self )
        _endif
	#
	#   Now that the report has been generated, activate the report window:
	#
	rpt_win.activate()
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing)
pni_trace_result_lister.define_shared_constant(:report_viewer_definitions,
					       property_list.new_with(:path_loss_detailed_report!signal,
								      mit_detailed_optical_loss_report,
								      :path_loss_summary_report!signal,
								      mit_overview_optical_loss_report),
					       :public)
$

_pragma(classify_level=restricted, topic=mit_tracing)
_method pni_trace_result_lister.generate_results_tree_report( a_rpws )
        ##
        ##  Activate the report previewer and report on the trace results.
        ##
        _if a_rpws _is _unset
        _then
                a_rpws << report_previewer.new(60,30).activate()
        _endif
	top << .result_trees[ _self.display_level ]
	_if top _isnt _unset
	_then
		top.dump( 0, space_char, a_rpws.output )
		a_rpws.title << top.display_string
	_endif
	a_rpws.output.flush()
	_return a_rpws
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing)
_method pni_trace_result_lister.highlight_selection()
        ##  Highlight the currently selected objects.

        _local td << mit_manager.get_tree_descriptor(_unset, _self.context)
        ( nodes ) << _self.results_lister_selected_nodes()

	gs << geometry_set.new_from( nodes )
	
	.owner.plugin.highlight( gs )
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing)
_method pni_trace_result_lister.goto_selection()
        ##  Goto the currently selected objects.

        ( nodes ) << _self.results_lister_selected_nodes()

	_if nodes.empty?
	_then
		_self.goto()

	_elif nodes.size _is 1 _andif
	      (a_geom << nodes.an_element()) _isnt _unset _andif
	      (an_rwo << a_geom.rwo) _isnt _unset
	_then
		pam << .owner.application.manager
		pam.goto_primary_context( an_rwo )
	_else
		rwos << rwo_set.new()
		
		_for n _over nodes.fast_elements()
		_loop
			rwos.add( n.rwo )
		_endloop 
		
		.owner.plugin.goto( rwos )
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing)
_method pni_trace_result_lister.note_change( who, why, _gather what )
	## 
	##
	##
	mbr << _self.menu_buttons[ :results ]
	_if who.is_class_of?( popup_handler ) _andif
	    why _is :event_raised _andif
	    mbr.includes_key?( what[2] )
	_then
		_self.perform( mbr[ what[2] ] )
	_endif
	_if who.is_class_of?( tree_list_view_component ) _andif
	    why _is :event_raised                        _andif
	    (
	      what[1] = :selection _orif
	      what.size > 1 _andif (
				     what[2] = :select_all    _orif
				     what[2] = :select_others _orif
				     what[2] = :clear_selection
				   )
	    )
	_then
		_self.manage_actions( :tree_selection )
	_endif
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing, usage=internal)
_method pni_trace_result_lister.results_lister_selected_nodes()
	##
	##  Returns the geoms of the selected node-like objects.
	##
	##  Because the selected items may not have geoms if they are
	##  (eg) entered splices within structures, they are mapped to
	##  their Top Housings, whose geoms are returned.
	##
	rwos  << _self.results_lister_selected_rwos()
	geoms << geometry_set.new()
	_for an_rwo _over rwos.fast_elements()
	_loop
		th << an_rwo.top_housing
		_if th.type_is?( :building )
		_then
			#   Cannot use .location for a building because
			#   that will be UNSET if the building has an
			#   outline. But .connection_location will always
			#   be ok, so use that:
			geoms.add( th.connection_location )
		_else
			geoms.add( th.location )
		_endif
	_endloop
	_return geoms
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing, usage=internal)
_method pni_trace_result_lister.set_selection_as_stop_node()
	##
	##  Picks up the geoms of the selected nodes in the result
	##  lister, maps them to RWOs, and passes them as new start
	##  RWOs.
	##
	es << _self.results_lister_selected_rwos()
	.owner.import_stop_rwos( es )
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing, usage=internal)
_method pni_trace_result_lister.set_selection_as_start_node()
	##
	##  Picks up the geoms of the selected nodes in the result
	##  lister, maps them to RWOs, and passes them as new start
	##  RWOs.
	##
	es << _self.results_lister_selected_rwos()
	.owner.import_start_rwos( es )
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing)
_method pni_trace_result_lister.update_label()
	## 
	##  Update label as per trace level, display level, start node,
	##  medium, and direction.
	##
	dlevel    << _self.message( _self.display_level )   #   for display level (:overview or :detail)
	tlevel    << _self.message( .owner.trace_level )    #   for  trace  level (:cable or :signal)
	medium    << .owner.current_medium_description
	direction << .owner.current_direction_description
	.menu_items[:label].value << _self.message( :label, _unset, tlevel, medium, direction, dlevel )
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing, usage=internal)
_method pni_trace_result_lister.select_in_map()
	##
	## Description:
	##  Make self geometries available on the application databus
	##  under the data_type set_map_selection
	##  Eventually this will set the current object geometries as the current
	##  selection on the map(s) view(s)
	##
	## Prerequisites:
	##  <any specific prerequisites or assertions>
	##
	## Parameters:
	##  <a description of each parameter passed to the method>
	##
	## Further side-effects:
	##  Setting the map selection will cause the Detailer to update
	##
	_local rwos << _self.results_lister_selected_rwos()
	_local top_rwos << rwo_set.new()

	_for i_rwo _over rwos.elements()
	_loop
		_local top_housing
		
		_if ( top_housing << i_rwo.top_housing ) _isnt _unset
		_then
			top_rwos.add( top_housing )
		_endif
	_endloop
	
	.owner.plugin.select_in_map( top_rwos )
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing, usage=internal)
_method pni_trace_result_lister.help()
	## 
	##
	.owner.plugin.help(_self.help_id)
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.display_trace_results_tree()
	##
	##  Display the previously generated results trees in the
	##  current activated lister.
	##
	_self.results_list.set_tree( _unset )
	_self.update_label()
	_self.set_display_level( _self.display_level )  #   generate the tree
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.manage_actions(_optional mode)
	## 
	## Manages the enabled state of the actions.
	##

	_local l_popup_menu  << _self.results_list.top.menu

	_if mode = :tree_selection
	_then
		_local send_to_div_item

		_for pop_item  _over l_popup_menu.items.fast_elements()
		_loop
			_if pop_item.label = _self.message( :send_to_diversity )
			_then
				send_to_div_item << pop_item
			_endif
		_endloop
		
		.menu_items[:send_to_diversity].enabled? << send_to_div_item.enabled? << 
			((sel << _self.results_list.get_selected_objects()).size = 1 _andif
			 sel.an_element().is_leaf? _andif
			 sel.an_element().object_data _isnt _unset)
	_elif mode = :popup_init
	_then
		# add any other popup items to initially disable here in
		# actions_to_disable - have to do this kludge as this
		# component is pre-swaf/pre-action.
		actions_to_disable << {:send_to_diversity}  
		_for pop_item _over l_popup_menu.items.fast_elements()
		_loop
			_if pop_item.responds_to?(:selector) _andif actions_to_disable.includes?(pop_item.selector[2])
			_then
				pop_item.enabled? << _false 
			_endif
		_endloop
		
	_else 
		_for i_item _over l_popup_menu.items.fast_elements()
		_loop
			_if i_item.label = _self.message(:update_fibre_priority)
			_then
				enabled? << .owner.trace_preset _is :fibre_priority _andif
					    _self.result_trees[ :detail ].default( { } ).size > 0
				i_item.enabled? << enabled?
				.menu_items[:update_fibre_priority].enabled? << enabled?
			_endif
		_endloop
	_endif 
_endmethod
$

_pragma(classify_level=restricted,topic=pni_tracing_plugin)
_method pni_trace_result_lister.update_fibre_priority()
        ##
        ##  Create, cache and activate the dialog to update fiber priority.
        ##
	
	_if ( p << .sub_menus[ :fibre_priority_updater ] ) _is _unset
	_then
		p << .sub_menus[ :fibre_priority_updater ] << pni_fibre_priority_updater.new_dialog( _self )
	_endif
	
	p.activate()
	
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing, usage=internal)
_method pni_trace_result_lister.results_lister_selected_rwos()
	##
	##  Returns the RWOs of the selected node-like objects.
	##
	##  The returned RWOs will not have location geometries if they
	##  are (eg) entered splices within structures.
	##
	#
	#   This method is called eg as a result of Goto Selection and Highlight
	#   Selection operations after a cable trace or a signal trace.
	#
	td   << mit_manager.get_tree_descriptor( _unset, _self.context )
	rwos << rwo_set.new()   #   Note:   An rwo_set can hold pseudo-objects too.
	_for aot _over _self.results_list.get_selected_objects().fast_elements()
	_loop
		od << td.get_data( aot )
		_if od _is _unset
		_then
			#   Happens in the case of a result tree line
			#   that does not represent an object.
			_continue
		_endif
		_if od.class_name _is :pseudo_node
		_then
			#
			#   Can happen as a result of splitting links
			#   due to cost limits. There is no RWO to
			#   report.
			#
			#   FUTURE: It will be necessary to address this problem
			#           in some way in the future because the
			#           returned RWOs can be used in determining
			#           zoom bounds in the map for a Goto Selection
			#           operation. The pseudo_node ought to be
			#           contained within the zoom bounds but we have
			#           no way to make that happen as only RWOs can
			#           be handled. Unless perhaps a pseudo-object
			#           can be devised that will emulate an RWO in
			#           relevant needed ways.
			#
			_continue
		_endif
		#
		#   At this point we USED to do:
		#
		#       od << od.get_top_level_device()
		#
		#   But if we have a cable trace, 'od' will already be a
		#   top-level device or structure (regardless of the
		#   display_level setting).
		#
		#   And if we have a signal trace, we do not want to map
		#   to top-level stuff, we want to be able to use the
		#   nodes AS-IS. (If the display_level is :overview,
		#   they will have been so-mapped. If it is :detail,
		#   they will not. So we get a lot of flexibility.)
		#
		_if od.class_name _is :mit_redundant_trace_node
		_then
			#   eg for a mit_pseudo_fiber_pin whose .sheath_pin is a mit_pseudo_cable_pin
			_continue
		_endif
		rwos.add( od )
	_endloop
	_return rwos
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing, usage=internal)
_method pni_trace_result_lister.send_to_diversity_checker()
	## 
	## DESCRIPTION:
	## Send selected objects in result tree to Bearer diversity
	## checker. 

	sp << .owner.plugin.get_service_provider(:diversity_check)
	sp.send_to_diversity( _self.path_elements(), _self )
	
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing, usage=internal)
_private _method pni_trace_result_lister.path_elements()
	## 
	## DESCRIPTION:
	## Returns objects on the selected trace branch for use with
	## diversity checking. Returns both RWO and pseudo objects.
	##
	## RETURN VALUES:
	## sel_objects :- rope containing list of RWO and pseudo
	## objects currently selected in the trace result lister.

	select_element << _self.results_list.get_selected_objects().an_element()
	objs << rope.new()
	

	# Climb up the branch to the root node collecting the objects
	_loop
		_if (obj << select_element.object_data) _is _unset 
		_then
			_leave 
		_else
			objs.add_last( obj ) 
		_endif
		select_element << select_element.parent
	_endloop
	
	_return objs.reversed()
	
_endmethod
$

_pragma(classify_level=restricted, topic=mit_tracing)
_method pni_trace_result_lister.set_trace_lister_report_options( medium, cost )
	##
	##  Set the different report options based on:
	##
	##      MEDIUM      trace medium        (eg :independent or :rf)
	##
	##      COST        trace cost type     (eg :none or :signal_loss)
	##
	##  Called by pni_trace_dialog.display_results_lister().
	##
	items << rope.new()
	l_rep_rules << _self.report_rules[ medium, cost ].default( {:results_tree_report, :schematics } )
	_for i_rep_type _over l_rep_rules.fast_elements()
	_loop
		items.add_last( {i_rep_type, _self.message( i_rep_type )} )
	_endloop
	items.add_last({:rw_trace_diagram, "Trace Diagram"})
	.menu_items[ :generate ].items << items
 _endmethod
$

_pragma(classify_level=restricted)
_method pni_trace_result_lister.wm_close()
	## 
	## Callback method for closing the dialog via Window System's
	## 'X' button.

	_self.suspend()
	_return _true
_endmethod
$

